[[{"i":"#","p":["Home Page"]},{"i":"welcome","l":"Welcome!!","p":["I'm Yash Thakre from \uD83C\uDDEE\uD83C\uDDF3, a passionate learner and developer with a deep interest in the broader realm of software development. Throughout my journey, I've ventured into diverse technologies, tackled intriguing problems, and had the privilege of collaborating with exceptional minds.","I'm delighted to have you here! This platform serves as a window into my world, where I share my curiosities, learnings, projects, and all things related to Software development and DSA. I've meticulously crafted this website using Retype, a powerful static site generator, to showcase my work in an organized and accessible manner.","Please feel at home as you navigate through the diverse sections and articles on this site. You can also check out my Blog. Within these pages, I've curated a collection of thought-provoking blog posts that delve into topics I find fascinating. Whether you're a fellow developer or a curious learner, I'm confident you'll find valuable insights and ideas here."]},{"i":"lets-connect","l":"Let's Connect...","p":["I firmly believe that continuous learning is the catalyst for personal and professional growth. This website acts as a living documentation of my explorations, where I share my experiences, insights, and the invaluable lessons I've acquired along the way.","Should you wish to connect with me or have any inquiries, I'm readily available on my social media platforms. Engaging with like-minded individuals and fostering meaningful discussions is a passion of mine, so don't hesitate to reach out. Let's connect and collaborate!"]},{"l":"Socials","p":["LinkedIn","Github","Resume"]}],[{"l":"Alembic","p":["Alembic is a lightweight database migration tool for SQLAlchemy (python). Just like we have a version control for Git, Alembic acts as a version control for the Database."]},{"l":"Setup","p":["This section contains information about the steps to setup alembic and also what each of its files mean. If you want to know more about the implementation, you can g","Since Alembic is a python tool, you can easily install by using pip package manner. Just run the following command to install alembic in your environment.","Once this is done, we are ready to use alembic, you can try writing alembic in the terminal to see if it is installed.","Now to start with alembic, we need to initialise our project. So just like git we run the init method to set up alembic for our project.","Once you have initialised alembic, a new folder named alembic will pop up along with a file called alembic.ini. The folder structure for that folder will be as follows:","Here's what these files do: 1. alembic.ini: This is the configuration file for alembic. It defines the database connection and other information which alembic uses to do the migrations. We can also mention things like which tables to include/exclude etc. Following is a sample alembic.ini file:","There might be cases where we want to use multiple .ini files for different cases. Say for example you can have a prod.ini, dev.ini etc. We can then explicitly specify which file to use.","env.py: This is a Python script that sets up the migration environment and provides the necessary configurations for Alembic to manage database migrations.","versions: Versions is a folder which contains all the migration scripts for upgrading or downgrading the datbase. The files inside version are mostly auto-generated and we just need to edit them as per our use-case."]},{"l":"General Flow of things","p":["In alembic, for most use-cases, the following flow is followed:"]},{"l":"Key Commands","p":["Alembic has the following commands available for us in its CLI:","From the above, the ones that are the most important are history, revision and upgrade."]},{"l":"History","p":["History is like your git log. It shows all the changes made in their appropriate order. It shows all the changes/commits or revisions along with their description and the head.","To view the history, we need to run alembic history"]},{"l":"Revision","p":["A revision in alembic is like a git commit. It marks a change in the DB and contains the details about how to get to that state or come back from the state.","Every revision has a description and also a unique hash. This hash can then be used upgrade or downgrade to that particular revision.","To create a new revision we run","This will create a new revision file inside the version.","Here, we can see, every revision has an ID. It also states the revision it upgrades or goes back to. If in case there is a conflict where 2 revisions roll back to the same version, we can change the down_revision values to put them in the right order.","The revision also has other features like","--rev-id is used to give a custom ID to the revisions.","--autogenerate goes through the DB and compares the difference between the DB and the scripts. And it autogenerates the commands to bring the scripts upto the DB. This can be useful when you are doing manual additions to the DB and want to have them added to the scripts too.","Alembic keeps a track of the current version in the DB with the help of a table called alembic. So if we ever need to check the verison of something we can check it on the DB. The local version is dictated by the revision files. Alembic iterates through all the revision files to generate a history."]},{"l":"Upgrade and Downgrade","p":["Whenever we have changes that need to be migrated to the DB, we run the upgrade command. The upgrade command checks the DB and runs all the scripts between the version in the DB and the current local version.","This brings the DB to the latest revision. In case we need to upgrade to a specific revision, we can directly mention the id of that commit. alembic upgrade id","Similar to upgrade, downgrade brings down the DB to a previous revision if we mention that ID OR we can mention it relative to the head."]},{"l":"Conclusion","p":["This was a very brief overview of alembic and what its capabilities are. There are a lot more concepts like branching, merging branches etc. But on the broader scale, this is how alembic is used to migrate and control database schemas. It's a useful tool for simplifying and organising database migrations."]}],[{"l":"Learning React the HARD Way","p":["Documenting my journey of learning react, the hard way. Reading and going through the documentation.","I will be writing everything here in this repo. This can be considered as either my notes or progress tracker. My ultimate goal will be to build something like 'Dime' but for habits.","Setting Up React : Installation","Documentation","React - Quick Overview"]}],[{"l":"Quick Overview of Basics"},{"i":"definition","l":"Definition:","p":["A react app is completely made up of components.","A component is a piece of the UI that has its own logic and appearance","A component can have other components as well. Thus it can either a simple button OR an entire page. The only rule is that it should have its own logic and appearance.","This was the concept of a component, but in technical terms: \"A component is just a JS function that returns markup / HTML\". This function tells react what to render.","The only caveat is that a components name should always start with a 'capital letter'.","A file can export multiple components if it wants to and there can even be 1 default component that a file exports. But as a good practice, it is better for 1 file to have 1 component. Also a component can have multiple components in it."]},{"l":"JSX","p":["The markup that we return from the component is called JSX. It is a stricter version of HTML that needs all tags to be closed and each component can return only a single JSX tag. In things cases where we want to have multiple tags to be returned, we wrap them in a dummy tag like : .../","To style the components, we can give the components a class and then use those classes to add styles in a separate scss or css file."]},{"l":"Making the JSX Dynamic","p":["In JSX, we can insert variables or logic using {}. Anything inside them is considered and evaluated like normal javascript. These curly braces can be used to display variables, return a list of elements, conditionally render elements etc."]},{"l":"Conditional Rendering","p":["There can be multiple ways to conditionally render:","Using a variable and then having multiple returns:","Or we can use a conditional operator for this and directly render within one return statement","We can use a similar process handle on-click functionalities etc."]}],[{"i":"react---installation","l":"React - Installation","p":["I referred the following document for react installation","The only pre-requisite for react is node.js installed on the system. If we want to deploy it globally, then we don't even need nodeJS as a react website can be directly exported to static HTML, CSS, JS files.","Ideally, the recommended way of using react is using a well defined framework like NextJS, Gatsby, Remix etc.","This is because react in itself doesn't support a lot of things that might be needed for a full fledged web application. React is ideal for single page apps but for more complex, setting up everything manually can be a huge challenge.","For the purpose of learning all the fundamentals and inner workings of React, I will go with the standard react without a framework and then later on progress to something like NextJS."]}],[{"l":"Docker basics"},{"i":"what-is-a-container","l":"What is a container?","p":["It is a containerisation platform. The main difference between containers and VMs is that the VMs work on top of hardware level. They directly take that resource whereas the containers work on top of the base OS. They use the resources of the base OS to process.","Unlike VMs, containers are not meant to run OS, they are meant to run only specific tasks. Once that task/process is done, the container is supposed to shut down.","A CONTAINER LIVES ONLY AS LONG AS THE SERVICE INSIDE IT IS ALIVE","If the service/process crashes, the container stops.","Some use cases can be : Do a calculation, host service, host website etc.","For eg: If we run a container without a service, it will start and immediately stop as there's no process."]},{"i":"basic-docker-commands","l":"Basic Docker Commands:"},{"i":"run---start-a-container","l":"run - Start a container","p":["docker run image-name This starts a container with the given image name. It first checks for the image in the local host, if not found then goes to docker hub to get the image. Each container that is created using this command is given a unique ID and name.","docker run image-name commands Since a container requires a process that will be run on that, we can pass in a command while starting the container. This command will be run on the container as soon as it is started.","eg: docker run ubuntu sleep 10-> This will create a container using Ubuntu image and then run sleep 10. Thus the system will sleep for 10 seconds and after that, since there's no process left, the container will terminate.","When we run a docker container using docker run, it waits for the container to finish and holds the terminal input till that time. We can view at the stdout of the container but can't give input.","The run command has a lot of flags and options. Docker basics: contains detailed information about the run command."]},{"i":"attach---attach-to-a-running-container","l":"attach - Attach to a running container","p":["docker attach container-id We can use this to attach to a running container. This way, we can look at its logs to the stdout. The container id doesn't need to be exact, only the first few unique characters are sufficient for that."]},{"i":"ps---list-containers","l":"ps - List Containers","p":["docker ps options It is used to list all the containers. By default it is used to list running containers. But -a can be used to view all types. Running, stopped etc."]},{"i":"stop---stop-container","l":"stop - Stop Container","p":["docker stop container name / container ID It is used to just stop a container from working. Doing this does not delete the container, it just pauses it, it still lives on the disk drive. The resources of the container are not cleared. If we want to do that, we use rm","We can pass multiple containers to the stop command. eg: docker stop aee1 qwe2 asd4 ... and it will stop all of them at once."]},{"i":"rm---removedelete-container","l":"rm - Remove/Delete Container","p":["docker rm container name / container ID It completely deletes a container and its resources. (To delete a container, it first needs to be stopped) Similar to stop, we can pass multiple containers to the rm command to remove all at once."]},{"i":"images---list-images","l":"images - List images","p":["Shows all the images available on the local host. In case we need to download an image but not start a container from it. We use docker pull image name","docker rmi image-name","We need to make sure that the image is not being actively used."]},{"i":"exec---run-commands-on-running-container","l":"exec - Run Commands on running container","p":["docker exec commands This is used to run commands on running docker containers. eg: docker exec echo /cat/etc"]},{"i":"inspect---inspect-container-details","l":"inspect - Inspect Container Details","p":["Although docker ps gives us some information about the container, if we need additional comprehensive information, we use inspect.","docker inspect container name / ID shows the details about the container in a JSON format."]},{"i":"logs---view-container-logs","l":"logs - View Container Logs","p":["When we run a container in detached mode, we cannot see the logs in our terminal directly. For this we use the logs command.","docker logs container name / ID shows all the STDOUT logs of the container."]}],[{"l":"Docker images","p":["How do we create our own image? We might need to create our own image when we need to add something to an existing image or we want to create something fresh tailored to our need.","We can imagine creating an image as parallel to deploying the code manually. Assuming we need to deploy a flask server, we will take the following steps:","Setup OS","update libraries","Install dependencies","Install python","pip install flask","Copy/Fetch the code","Run the server with the needed config","For creating an image, we follow a similar approach: All the steps that we need to perform to prepare the image are written to a Docker File. And this is then used to build the container."]},{"l":"Docker build","p":["It is used to create an image from the dockerfile.","docker build name of dockerfile -t image/tagname","This creates a local image of the dockerfile. To push this image to docker hub, we use docker push image name","Docker build command works on a directory and not single dockerfile.-t: used to give a name/tag to to the image","Eg: Creating an image with a tag : docker build . -t name:tag"]},{"l":"Layered Architecture","p":["Each line in the Docker File represents a layer in the process of building the image. Each layer contains only the changes that are needed to come from the previous layer to current state. This allows it to be very efficient and fast. Docker also stores the progress of each layer in cache. So that in case there is an error or changes to a layer, it picks up the previous layers from the cache and continues building on top of it."]},{"i":"commands-vs-entrypoint","l":"Commands v/s Entrypoint","p":["Commands (CMD) are the commands that will run when the container has started. We can pass the values to CMD in 2 ways. String and JSON Array.","This is a neat way of running a command instead of passing it every time in docker run.","But there might be cases, where might want to make it more dynamic, then in that case we use ENTRYPOINT","ENTRYPOINT is like CMD, but the only difference is that in case of CMD, any input afterwards or with the help of the command line override the CMD command whereas for ENTRYPOINT, it appends the additional commands.","If there is any case, where we need to pass in a different entrypoint altogether, we can do so by using --entrypoint with Docker Run."]}],[{"l":"Docker run"},{"l":"Tag","p":["Every image on docker hub, has a tag associated to it. It is similar to a version for the image. By default, when we run an image using docker run image, it uses the latest tag by default.","To specify the tag, so that we can run an specific version, we can use : with the image name.","To know about all the versions and tags for an image, we can go to Docker Hub and look for all the tags or versions in the description of an image."]},{"i":"detached-mode--d","l":"Detached Mode (-d)","p":["To run the container in detached mode, we the -d flag. In case we have detached from a container and want to go back to it, we use the attach command."]},{"i":"name-container---name","l":"Name Container (--name)","p":["It is used to give the container a unique name so that it can be easily referenced. eg: docker run --name Name image"]},{"l":"STDIN","p":["When we normally run a docker container, we are attached to the container session but we cannot pass any input to the container. We are just spectators and can read the outputs. To be able to provide our inputs to the container, we need to map our STDIN (standard input) to the containers. This is done with the -i flag.","Eg: docker run -i image: Allows us to run in interactive mode. Which allows us to map our terminal STDIN to the container's.","If we want to completely map our terminal to the container, we use -it flag which represents interactive terminal mode. Eg: docker run -it image","To exit from the interactive mode, type exit in the shell."]},{"i":"port-mapping--p","l":"Port Mapping (-p)","p":["This is one of the most important concepts for the usability of docker. For a container to be useful, it needs to interact with the outside world. This is where port mapping comes in. It allows us to map a port from our host to the container.","Host = Machine on which docker is running","Container = Docker container in which our app is running","There are 2 ways to access this container:","Internal IP : Every docker container is given an internal IP address. Thus we can use this IP address to access the container. But this allows only the 'Host' to access the container (as it is an internal IP). Any machine/user outside the host machine cannot use the internal IP.","Port mapping: For the container to be connected to the world, we need to map a port from the container (p1) to a port on the host (p2). This way all the traffic on the p2 is redirected to p1. To do this, we use the -p flag : docker run -p p2:p1 image","Eg: docker run -p 8000:5000 ubuntu-> All the traffic from the host's port 8000 is forwarded to the port 5000 of the container. So when an external user hits port 8000 of host, it is actually hitting port 5000 of the container.","We can also map multiple ports from our container. Say we want to map port 5000 and 5500 from our container to 8000 and 8500 on host, we will call the -p flag twice. Eg: docker run -p 8000:5000 -p 8500:5500 image","In the above, we can see that when we run the ps command, the ports are displayed. It shows that the port 8000 from the host (0.0.0.0) is mapped to 5000 of the container","The internal IP of the docker container can be found in the networks section in docker inspect"]},{"i":"volume-mapping--v","l":"Volume Mapping (-v)","p":["When a container is created, it has its own isolated filesystem. Any changes to the files within the container are its own. If we stop the container, the data is still there. But when we stop a container, all data is lost. If we want to avoid this, so that the data is still persisted even after we are done with container, we can map it to a local directory on the host using the -v flag.","docker run -v path on host:path on container image","Observation: When using flags like -v and -p, the host always comes first and then the container. ie: host:container"]},{"i":"environment-variables--e","l":"Environment Variables (-e)","p":["Sometimes, we need to pass in environment variables to pass with the image. This can be done using the -e flag. This flag followed by the values sets the env variables for the image.","In case we need to view the environment variables for the container that is already running, we can use docker inspect to do that."]},{"i":"entrypoint---entrypoint","l":"Entrypoint (--entrypoint)","p":["Whenever we need to override or provide a custom endpoint, we use this flag."]}],[{"l":"DockerFile","p":["A dockerfile is a text-file with the name Dockerfile that stores all the commands to build a docker image. It contains step by step instructions to build the image.","Sample Dockerfile:","The dockerfile follows a INSTRUCTION ARGUMENT format. Every line starts with an instruction (in all caps) followed by the argument for that instruction","FROM: This instruction specifies the base image or OS for the image. Each dockerfile starts with a FROM instruction.","Every dockerfile needs to have a base image or OS","RUN: This instruction runs the arguments provided while building the image.","COPY: Used to copy files","ENTRYPOINT: Allows us to specify a command that will be run when the image is run."]}]]